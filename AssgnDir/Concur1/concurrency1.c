/*
 * Program: producer_consumer.c
 * Authors: Jacob Mahugh & Alannah Oleson
 * Date: 10/06/2017
 * Description: For concurrency problem 1 in OS II (CS444). This program
 * spawns multiple producers and multiple consumers, the numbers of which
 * are dictated by the command line. Producers add events to a shared FIFO,
 * while consumers pop items from the FIFO. Sleep_times and item numbers
 * are randomly generated by either RDRand hardware (if supported) or the 
 * Mersenne Twister algorithm, which has been copy & pasted into this 
 * program.
 *
 */

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <sys/queue.h>
#include <stdlib.h>
#include <stdbool.h>
#include <pthread.h>
#include <unistd.h>

/* Period parameters */  
#define MAX 32
#define N 624
#define M 397
#define MATRIX_A 0x9908b0dfUL   /* constant vector a */
#define UPPER_MASK 0x80000000UL /* most significant w-r bits */
#define LOWER_MASK 0x7fffffffUL /* least significant r bits */

//Below thanks to mouviciel:
// https://stackoverflow.com/questions/523724/c-c-check-if-one-bit-is-set-
// in-i-e-variable
#define CHECK_BIT(var, pos) ((var) & (1<<(pos)))

static unsigned long mt[N]; /* the array for the state vector  */
static int mti=N+1; /* mti==N+1 means mt[N] is not initialized */

bool isDebug = false;

struct producerArgs{
	long tid;
	long sleep_time;
	unsigned int ecx;
};

struct item{
	unsigned long randNum;
	int sleep_time;
};
/*
 * Queue implementation borrowed & modified from:
 * https://www.tutorialspoint.com/data_structures_algorithms
 * /queue_program_in_c.htm
 */
struct item sharedQueue[MAX];
int front = 0;
int rear = -1;
int itemCount = 0;
pthread_mutex_t lock;

bool isEmpty() {
	return itemCount == 0;
}

bool isFull() {
	return itemCount == MAX;
}
void insert(struct item data) {
	
	if(!isFull()) {

		if(rear == MAX-1) {
			rear = -1;
		}

		sharedQueue[++rear] = data;
		itemCount++;
	}
}

struct item removeData() {
	struct item data = sharedQueue[front++];

	if (front == MAX) {
		front = 0;
	}

	itemCount--;
	return data;
}
/*
 * Mersenne Twister Implementation by:
 * 
 * Takuji Nishimura and Makoto Matsumoto
 * http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
 * email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)
 */

/* initializes mt[N] with a seed */
void init_genrand(unsigned long s)
{
	mt[0]= s & 0xffffffffUL;
	for (mti=1; mti<N; mti++) {
		mt[mti] = 
			(1812433253UL * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti); 
		/* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
		/* In the previous versions, MSBs of the seed affect   */
		/* only MSBs of the array mt[].                        */
		/* 2002/01/09 modified by Makoto Matsumoto             */
		mt[mti] &= 0xffffffffUL;
		/* for >32 bit machines */
	}
}

/* initialize by an array with array-length */
/* init_key is the array for initializing keys */
/* key_length is its length */
/* slight change for C++, 2004/2/26 */
void init_by_array(unsigned long init_key[], int key_length)
{
	int i, j, k;
	init_genrand(19650218UL);
	i=1; j=0;
	k = (N>key_length ? N : key_length);
	for (; k; k--) {
		mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525UL))
			+ init_key[j] + j; /* non linear */
		mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
		i++; j++;
		if (i>=N) { mt[0] = mt[N-1]; i=1; }
		if (j>=key_length) j=0;
	}
	for (k=N-1; k; k--) {
		mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941UL))
			- i; /* non linear */
		mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
		i++;
		if (i>=N) { mt[0] = mt[N-1]; i=1; }
	}

	mt[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */ 
}

/* generates a random number on [0,0xffffffff]-interval */
unsigned long genrand_int32(void)
{
	unsigned long y;
	static unsigned long mag01[2]={0x0UL, MATRIX_A};
	/* mag01[x] = x * MATRIX_A  for x=0,1 */
	if (mti >= N) { /* generate N words at one time */
		int kk;

		if (mti == N+1)   /* if init_genrand() has not been called, */
			init_genrand(5489UL); /* a default initial seed is used */

		for (kk=0;kk<N-M;kk++) {
			y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
			mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1UL];
		}
		for (;kk<N-1;kk++) {
			y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
			mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1UL];
		}
		y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);
		mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1UL];

		mti = 0;
	}
  
	y = mt[mti++];

	/* Tempering */
	y ^= (y >> 11);
	y ^= (y << 7) & 0x9d2c5680UL;
	y ^= (y << 15) & 0xefc60000UL;
	y ^= (y >> 18);

	return y;
}

int getRandInt(unsigned int ecx, unsigned int beginRange,
	   	unsigned int endRange) {
	int i;
	if (CHECK_BIT(ecx, 30)) {
		__asm__ __volatile__ (
							  "rdrand %0;"
							  : "=a"(i)
				);	 
		i = (i % ((endRange-beginRange)+1) ) + beginRange;
	} else {
		i = (genrand_int32() % ((endRange-beginRange)+1) ) + beginRange;
	}
	return i;
}

void *producerAction(void *args2) {
	struct producerArgs *args = (struct producerArgs*)args2;
	int testcnt;
	for (testcnt = 0; testcnt < 10; testcnt++) {
		if (!isDebug)
			testcnt--;
		struct item insItem;
		int new_sleep;
		while (itemCount >= MAX) {}
		pthread_mutex_lock(&lock);
		if (itemCount >= MAX) {
			pthread_mutex_unlock(&lock);
			continue;
		}
		insItem.randNum = getRandInt(args->ecx, 0, 100);
		insItem.sleep_time = getRandInt(args->ecx, 2, 9);
		insert(insItem);
		printf("Produced:\trandNum %d\tsleep_time %d\tprod %d-P\t"
				"sleeping for %d\n", 
				insItem.randNum, insItem.sleep_time, 
				args->tid, args->sleep_time);
		new_sleep = getRandInt(args->ecx, 3, 7);
		pthread_mutex_unlock(&lock);
		sleep(args->sleep_time);
		args->sleep_time = new_sleep;
	}
}

void *consumerAction(void *cid2) {
	int testcnt2; 
	int *cid = (int *)cid2;
	struct item poppedItem;
	for (testcnt2 = 0; testcnt2 < 10; testcnt2++) {
		if (!isDebug)
			testcnt2--;
		while (itemCount <= 0) {}
		pthread_mutex_lock(&lock);
		if (itemCount <= 0) {
			pthread_mutex_unlock(&lock);
			continue;
		}
		poppedItem = removeData();
	    printf("Consumed:\trandNum %d\tsleep_time %d\tcons"
			   " %d-C\tsleeping for %d\n",
			   	poppedItem.randNum, poppedItem.sleep_time,
			   	*cid, poppedItem.sleep_time);
		pthread_mutex_unlock(&lock);
		sleep(poppedItem.sleep_time);
	}

}

int main(int argc, char **argv) {
	if (argc < 3 || argc > 4) {
		printf("Proper formatting: concurrency_1 " 
			   	"(number of Consumers) (number of Producers) [debug]\n");
		return 400;
	} else if (argc == 4) {
		if (strcmp(argv[3], "debug") ){
			printf("Proper formatting: concurrency_1 " 
				   	"(number of Consumers) (number of Producers) [debug]\n");
			return 400;
		} else {
			isDebug = true;
		}
	}
	unsigned int eax = 0x01;
	unsigned int ebx = 0;
	unsigned int ecx = 0;
	unsigned int edx = 0;
	unsigned int beginRange = 2;
	unsigned int endRange = 9;
	int numConsumers = atoi(argv[1]);
	int numProducers = atoi(argv[2]);

	struct producerArgs producerValues[numProducers];
	int consumerIds[numConsumers];
	printf("%d Consumers, %d Producers\n---------BEGIN PROGRAM---------\n\n",
		   	numConsumers, numProducers);

    unsigned long init[4]={0x123, 0x234, 0x345, 0x456}, length=4;
	init_by_array(init, length); //Mersenne Twister Random Seed
	__asm__ __volatile__(
						"cpuid;"
						: "=a"(eax), "=b"(ebx), "=c"(ecx), "=d"(edx)
						: "a"(eax)
			);

	pthread_t producerThreads[numProducers];
	pthread_t consumerThreads[numConsumers];

	int cnt;	
	for (cnt = 0; cnt < numProducers; cnt++) {
		producerValues[cnt].tid = cnt;
		producerValues[cnt].sleep_time = getRandInt(ecx, 3, 7);
		producerValues[cnt].ecx = ecx;
		pthread_create(&(producerThreads[cnt]),
				NULL,
				producerAction,
				(void*)&producerValues[cnt]);
	}
	for (cnt = 0; cnt < numConsumers; cnt++) {
		consumerIds[cnt] = cnt;
		pthread_create(&(consumerThreads[cnt]),
				NULL,
				consumerAction,
				(void*)&consumerIds[cnt]);

	}

	for (cnt = 0; cnt < numProducers; cnt++) {
		pthread_join(producerThreads[cnt], NULL);
	}
	for (cnt = 0; cnt < numConsumers; cnt++) {
		pthread_join(consumerThreads[cnt], NULL);
	}
	return 0;
}
